# Containerization with Docker Solution

This document outlines the steps taken to containerize the Django messaging application using Docker and Docker Compose, fulfilling the requirements of the "Containerization with docker" project.

## Task 0: Set up a Docker environment

**Objective:** Containerize the Building Robust APIs project.

**Steps Taken:**

1.  **Locate the `messaging_app` project directory:**
    The `messaging_app` directory was successfully located at `../repos/alx-backend-python/messaging_app`.

2.  **Create `requirements.txt` file:**
    A `requirements.txt` file was generated by freezing the dependencies of the project's virtual environment (`venv_messaging`) using the command:
    ```bash
    source ../repos/alx-backend-python/venv_messaging/bin/activate && pip freeze > ../repos/alx-backend-python/messaging_app/requirements.txt
    ```
    The content of `requirements.txt` included `asgiref`, `Django`, `django-filter`, `djangorestframework`, `djangorestframework_simplejwt`, `PyJWT`, and `sqlparse`. `mysqlclient==2.2.4` was later added to support MySQL connectivity.

3.  **Create a `Dockerfile`:**
    A `Dockerfile` was created in the root of the `messaging_app` directory with the following content:
    ```dockerfile
    # Use an official Python runtime as a parent image
    FROM python:3.10

    # Set the working directory in the container
    WORKDIR /app

    # Copy the current directory contents into the container at /app
    COPY . /app/

    # Install any needed packages specified in requirements.txt
    RUN pip install --no-cache-dir -r requirements.txt

    # Make port 8000 available to the world outside this container
    EXPOSE 8000

    # Define environment variable
    ENV DJANGO_SETTINGS_MODULE=messaging_app.settings

    # Run the app
    CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
    ```

4.  **Build and run the Docker container:**
    *   Docker was verified to be installed.
    *   The Docker image was built using:
        ```bash
        cd ../repos/alx-backend-python/messaging_app && docker build -t messaging-app .
        ```
    *   The container was run in detached mode, mapping port 8000:
        ```bash
        docker run -d -p 8000:8000 messaging-app
        ```
    *   The running container was verified using `docker ps`.

## Task 1: Use Docker Compose for Multi-Container Setup

**Objective:** Learn how to manage multiple services using Docker Compose.

**Steps Taken:**

1.  **Stop previously running container:**
    The manually started container was stopped using `docker stop <container_id>`.

2.  **Create `.env` file:**
    A `.env` file was created in the `messaging_app` directory to store MySQL credentials:
    ```
    MYSQL_DB=messaging_db
    MYSQL_USER=user
    MYSQL_PASSWORD=password
    MYSQL_ROOT_PASSWORD=root_password
    ```

3.  **Create `docker-compose.yml` file:**
    A `docker-compose.yml` file was created with `web` and `db` services. Initial attempt used `mysql:5.7` which later caused an error requiring an upgrade to `mysql:8.0`. A healthcheck was also added to the `db` service to ensure the `web` service waits for the database to be ready.
    The final content of `docker-compose.yml` is:
    ```yaml
    version: '3.8'

    services:
      web:
        build: .
        command: python manage.py runserver 0.0.0.0:8000
        volumes:
          - .:/app
        ports:
          - "8000:8000"
        depends_on:
          db:
            condition: service_healthy
        env_file:
          - .env

      db:
        image: mysql:8.0 # Updated from 5.7 to 8.0
        environment:
          MYSQL_DATABASE: ${MYSQL_DB}
          MYSQL_USER: ${MYSQL_USER}
          MYSQL_PASSWORD: ${MYSQL_PASSWORD}
          MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
        volumes:
          - mysql_data:/var/lib/mysql
        healthcheck:
          test: ["CMD", "mysqladmin" ,"ping", "-h", "localhost"]
          interval: 10s
          timeout: 5s
          retries: 5

    volumes:
      mysql_data:
    ```

4.  **Configure `settings.py` for database connection:**
    The `messaging_app/messaging_app/settings.py` file was modified to import `os` and configure the `DATABASES` setting to use MySQL and read credentials from environment variables.
    The relevant section in `settings.py` was updated to:
    ```python
    import os
    # ...
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.mysql',
            'NAME': os.environ.get('MYSQL_DB'),
            'USER': os.environ.get('MYSQL_USER'),
            'PASSWORD': os.environ.get('MYSQL_PASSWORD'),
            'HOST': 'db',
            'PORT': '3306',
        }
    }
    ```
    Additionally, `mysqlclient==2.2.4` was added to `requirements.txt` to support the MySQL backend.

5.  **Use Docker Compose to build and run:**
    *   The `docker-compose` services were started and recreated after changes:
        ```bash
        cd ../repos/alx-backend-python/messaging_app && docker-compose up -d --force-recreate
        ```
    *   Initially, `db` service failed due to MySQL version incompatibility with existing volume data. The old volume (`messaging_app_mysql_data`) was removed using `docker volume rm` after bringing down the services with `docker-compose down`. Services were then brought up again.

6.  **Verify app interaction with MySQL database:**
    Database migrations were run successfully inside the `web` container:
    ```bash
    cd ../repos/alx-backend-python/messaging_app && docker-compose exec web python manage.py migrate
    ```

## Task 2: Persist Data Using Volumes

**Objective:** Understand how to use Docker volumes to persist database data.

**Steps Taken:**

This task was inherently completed during the setup of `docker-compose.yml` in Task 1. The `mysql_data` named volume was defined and mounted to `/var/lib/mysql` in the `db` service, ensuring data persistence.
```yaml
    volumes:
      - mysql_data:/var/lib/mysql
# ...
volumes:
  mysql_data:
```

---

This completes the containerization tasks.
